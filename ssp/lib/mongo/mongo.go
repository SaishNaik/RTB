package mongo

import (
	"context"
	"fmt"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"log"
	"net/url"
	"strings"
	"time"
)

type Client struct {
	uri        string
	db         *mongo.Database
	connection *mongo.Client
	timeout    time.Duration
}

func (client *Client) Auth(uri string, timeout int) (bool, error) {
	var e error
	// create a client using the mongo uri
	conn, e := mongo.NewClient(options.Client().ApplyURI(uri))
	if e != nil {
		return false, e
	}
	client.uri = uri
	client.connection = conn
	client.timeout = time.Duration(timeout) * time.Second
	// set a context timer "ctxTimeout" to make sure we don't
	// wait indefinitely for the connection to happen
	ctx, cancel := context.WithTimeout(context.Background(), client.timeout)
	defer cancel()

	// attempt to connect
	e = conn.Connect(ctx)
	if e != nil {
		fmt.Println(e)
		return false, e
	}

	// after connecting and not seeing any error, attempt to ping
	ctx, cancel = context.WithTimeout(context.Background(), client.timeout)
	defer cancel()
	e = conn.Ping(ctx, readpref.Primary())
	if e != nil {
		fmt.Println(e)
		return false, e
	}
	// success, let's assign
	// get db name from uri
	client.db = conn.Database(uri2db(client.uri))
	return true, e
}

// function to parse the db name string from the var uri
// assuming uri is something valid as Ping() was done before calling this
func uri2db(uri string) string {
	u, e := url.Parse(uri)
	if e != nil {
		fmt.Println(e)
		return ""
	}
	// path may have a leading /
	return strings.TrimLeft(u.Path, "/")
}

func (client Client) Find(transactionCtx context.Context, colname string, filter map[string]interface{},
	opt map[string]interface{}) ([]bson.M, error) {
	// select collection
	col := client.db.Collection(colname)

	// handle options
	opts := options.Find()
	if opt["skip"] != nil {
		opts.SetSkip(opt["skip"].(int64))
	}
	if opt["limit"] != nil {
		opts.SetLimit(opt["limit"].(int64))
	}
	if opt["sort"] != nil && opt["order"] != nil {
		opts.SetSort(bson.D{{opt["sort"].(string), opt["order"].(int64)}})
	}

	var e error
	var docs []bson.M

	// set context
	ctx, cancel := SetContext(transactionCtx, client.timeout)
	defer cancel()

	// fetch cursor
	cursor, e := col.Find(ctx, filter, opts)
	if e != nil {
		log.Println(e)
		return docs, e
	}

	// move cursor to fetch all
	e = cursor.All(ctx, &docs)
	if e != nil {
		log.Println(e)
		return docs, e
	}

	return docs, e
}

func (client *Client) InsertOne(transactionCtx context.Context, colname string, doc interface{}) (interface{}, error) {
	// select collection
	col := client.db.Collection(colname)

	// set context
	ctx, cancel := SetContext(transactionCtx, client.timeout)
	defer cancel()

	// insert
	result, e := col.InsertOne(ctx, doc)
	if e != nil {
		log.Println(e)
		return "", e
	}

	insertObjId, ok := result.InsertedID.(primitive.ObjectID)
	// if _id is generated by mongo
	if ok {
		return insertObjId.Hex(), e
	}
	/*
		_id can be different data types(e.g string, int, etc) since this can be overridden by client,
		so we need to return interface
	*/
	return result.InsertedID, e
}

func (client *Client) UpdateOne(transactionCtx context.Context, colname string,
	filter interface{}, update interface{}) (int64, error) {
	// select collection
	col := client.db.Collection(colname)

	// set context
	ctx, cancel := SetContext(transactionCtx, client.timeout)
	defer cancel()

	// update
	result, e := col.UpdateOne(ctx, filter, update)
	if e != nil {
		log.Println(e)
		return 0, e
	}
	return result.ModifiedCount, e
}
